

## Проблема: edge-функция отклоняет запросы (401 Unauthorized)

### Что показала диагностика

Аналитика последних 20 запросов к backend-функции `external-db`:
- **Все POST запросы возвращают 401** (Unauthorized)
- Функция запускается нормально (boot за 30ms), соединение с базой есть
- Но проверка авторизации внутри функции отклоняет токен

### Корневая причина

Клиентский код (`externalDb.ts`) получает токен так:

```text
getHeaders() -> supabase.auth.getSession() -> session.access_token
```

Метод `getSession()` возвращает **кэшированный** токен из памяти. Если токен истёк (они живут ~1 час), а автоматическое обновление ещё не сработало, на сервер уходит просроченный токен.

Повторная попытка (retry) снова вызывает `getSession()` -- и получает тот же просроченный токен. Результат: обе попытки возвращают 401, пользователь видит ошибку.

Почему "раз через раз": иногда автообновление успевает обновить токен ДО запроса данных, и тогда всё работает. Это зависит от таймингов и скорости сети.

### План исправления

#### Шаг 1. Исправить получение токена в externalDb.ts

Заменить `getSession()` на цепочку: сначала попробовать получить свежую сессию, если токен просрочен -- принудительно обновить.

Конкретно:
- Получить сессию через `getSession()`
- Проверить, не истёк ли `expires_at`
- Если истёк или близок к истечению (менее 60 секунд) -- вызвать `refreshSession()` для получения нового токена
- Использовать свежий `access_token`

#### Шаг 2. Добавить умный retry при 401

Сейчас retry просто повторяет запрос с тем же токеном. Нужно при получении 401:
- Принудительно вызвать `refreshSession()`
- Повторить запрос с новым токеном
- Если и после этого 401 -- тогда уже показывать ошибку

#### Шаг 3. Добавить логирование для диагностики

Добавить `console.warn` при обнаружении просроченного токена, чтобы в будущем было проще отлаживать подобные проблемы.

### Затронутые файлы

**`src/lib/externalDb.ts`** -- основные изменения:
- Функция `getHeaders()`: добавить проверку `expires_at` и автоматический refresh
- Функция `call()`: при 401 -- refresh токена перед retry

## Ожидаемый результат

- Платформа всегда отправляет актуальный токен
- Если токен истёк -- он автоматически обновляется перед запросом
- Если 401 всё равно пришёл -- одна попытка с принудительным обновлением
- Ошибка "не удалось загрузить данные" больше не появляется при нормальной работе сети
